// Equinet - Booking platform for horse service providers
// Database schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL")
}

model User {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String
  userType     String // 'provider' eller 'customer'
  firstName    String
  lastName     String
  phone        String?

  // Email verification
  emailVerified   Boolean   @default(false)
  emailVerifiedAt DateTime?

  // Geographic location (for customers to enable route matching)
  city         String?
  address      String?
  latitude     Float?
  longitude    Float?

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  provider                  Provider?
  bookings                  Booking[]
  notifications             Notification[]
  routeOrders               RouteOrder[]
  emailVerificationTokens   EmailVerificationToken[]
  reviews                   Review[]   @relation("CustomerReviews")

  @@index([latitude, longitude]) // For geo-queries
}

model Provider {
  id              String   @id @default(uuid())
  userId          String   @unique
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  businessName    String
  description     String?
  address         String?
  city            String?
  postalCode      String?

  // NEW: Geographic coordinates (geocoded from address)
  latitude        Float?
  longitude       Float?
  serviceAreaKm   Float?   @default(50) // Max service radius in km

  serviceArea     String? // DEPRECATED: JSON array av områden (keep for backward compatibility)
  profileImageUrl String?
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  services               Service[]
  availability           Availability[]
  availabilityExceptions AvailabilityException[]
  bookings               Booking[]
  routes                 Route[]
  routeOrders            RouteOrder[] // NEW: Provider-announced route orders
  reviews                Review[]

  @@index([isActive, createdAt])
  @@index([city])
  @@index([businessName])
  @@index([latitude, longitude]) // NEW: For geo-queries
}

model Service {
  id              String   @id @default(uuid())
  providerId      String
  provider        Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  name            String
  description     String?
  price           Float
  durationMinutes Int
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())

  bookings Booking[]

  @@index([providerId, isActive])
}

model Availability {
  id         String   @id @default(uuid())
  providerId String
  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  dayOfWeek  Int // 0-6 (0=Måndag, 6=Söndag)
  startTime  String // Format: "09:00"
  endTime    String // Format: "17:00"
  isClosed   Boolean  @default(false) // true = Stängt hela dagen
  isActive   Boolean  @default(true) // false = Raderad/inaktiv
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([providerId, dayOfWeek])
}

// Datumbaserade undantag för tillgänglighet (har prioritet över veckoschema)
model AvailabilityException {
  id         String   @id @default(uuid())
  providerId String
  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  date       DateTime @db.Date // Specifikt datum (endast datum, ingen tid)
  isClosed   Boolean  @default(true) // true = stängt hela dagen
  startTime  String? // Alternativa öppettider (null = stängt)
  endTime    String?
  reason     String? // Valfri anledning ("Semester", "Sjuk", etc.)

  // Arbetsplats för dagen (US-2)
  location   String?  // "Sollebrunn", "Alingsås centrum"
  latitude   Float?
  longitude  Float?

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([providerId, date])
  @@index([providerId, date])
}

model Booking {
  id            String      @id @default(uuid())
  customerId    String
  customer      User        @relation(fields: [customerId], references: [id])
  providerId    String
  provider      Provider    @relation(fields: [providerId], references: [id])
  serviceId     String
  service       Service     @relation(fields: [serviceId], references: [id])
  routeOrderId  String?
  routeOrder    RouteOrder? @relation(fields: [routeOrderId], references: [id])
  bookingDate   DateTime
  startTime     String
  endTime       String
  timezone      String      @default("Europe/Stockholm") // Timezone för korrekt DST-hantering
  status        String      @default("pending") // pending, confirmed, cancelled, completed
  customerNotes String?
  horseName     String?
  horseInfo     String?

  // Beräknad restid till denna bokning (för historik/rapportering)
  travelTimeMinutes Int?

  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  payment       Payment?
  review        Review?

  @@unique([providerId, bookingDate, startTime, endTime], name: "unique_booking_slot") // Förhindra exakta dubbletter vid race conditions
  @@index([providerId, bookingDate, status])
  @@index([customerId, bookingDate])
  @@index([serviceId])
  @@index([routeOrderId])
}

model Payment {
  id                String    @id @default(uuid())
  bookingId         String    @unique
  booking           Booking   @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  amount            Float     // Belopp i SEK
  currency          String    @default("SEK")

  // Payment provider (mock för demo, stripe/swish för produktion)
  provider          String    @default("mock") // "mock" | "stripe" | "swish"
  providerPaymentId String?   // Externt betalnings-ID

  // Status tracking
  status            String    @default("pending") // pending, succeeded, failed, refunded
  paidAt            DateTime?

  // Kvitto/Faktura
  invoiceNumber     String?   @unique
  invoiceUrl        String?   // URL till PDF-kvitto

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([bookingId, status])
  @@index([status, paidAt])
}

model Notification {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  type      String
  message   String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([userId, isRead])    // "Olästa notifikationer för användare"
  @@index([userId, createdAt]) // "Senaste notifikationer"
}

// Route-based delivery models
model RouteOrder {
  id                  String   @id @default(uuid())

  // Customer-initiated fields (nullable when provider-announced)
  customerId          String?
  customer            User?    @relation(fields: [customerId], references: [id])

  // NEW: Provider-announced fields
  providerId          String?
  provider            Provider? @relation(fields: [providerId], references: [id])
  announcementType    String   @default("customer_initiated") // 'customer_initiated' | 'provider_announced'

  // Shared fields (used by both flows)
  serviceType         String // t.ex. 'hovslagning', 'massage'
  address             String
  latitude            Float?   // Optional - geocoding not required for MVP
  longitude           Float?   // Optional - geocoding not required for MVP
  numberOfHorses      Int      @default(1)
  dateFrom            DateTime
  dateTo              DateTime
  priority            String   @default("normal") // 'normal' eller 'urgent'
  specialInstructions String?
  contactPhone        String?  // Optional - not needed for provider announcements
  status              String   @default("pending") // 'pending', 'in_route', 'completed', 'cancelled'
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  routeStops RouteStop[]
  bookings   Booking[]

  @@index([status, serviceType])
  @@index([status, priority])
  @@index([customerId, status])
  @@index([dateFrom, dateTo, status])
  @@index([providerId, announcementType, status]) // NEW: Provider announcements
  @@index([latitude, longitude, announcementType]) // NEW: Geo-search
}

model Route {
  id                   String   @id @default(uuid())
  providerId           String
  provider             Provider @relation(fields: [providerId], references: [id])
  routeName            String
  routeDate            DateTime
  startTime            String // Format: "08:00"
  status               String   @default("planned") // 'planned', 'active', 'completed', 'cancelled'
  totalDistanceKm      Float?
  totalDurationMinutes Int?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  stops RouteStop[]

  @@index([providerId, routeDate, status])
  @@index([status])
}

model RouteStop {
  id                   String     @id @default(uuid())
  routeId              String?    // Optional - announcements don't have Route
  route                Route?     @relation(fields: [routeId], references: [id], onDelete: Cascade)
  routeOrderId         String
  routeOrder           RouteOrder @relation(fields: [routeOrderId], references: [id])
  stopOrder            Int // 1, 2, 3... ordning i rutten
  locationName         String?    // NEW: "Alingsås centrum", "Sollebrunn" (för provider announcements)
  address              String     // NEW: Full address for the stop
  latitude             Float?     // NEW: Optional - geocoding not required for MVP
  longitude            Float?     // NEW: Optional - geocoding not required for MVP
  estimatedArrival     DateTime?
  estimatedDurationMin Int        @default(60) // Beräknad tid på plats
  actualArrival        DateTime?
  actualDeparture      DateTime?
  status               String     @default("pending") // 'pending', 'in_progress', 'completed', 'problem'
  problemNote          String?
  createdAt            DateTime   @default(now())
  updatedAt            DateTime   @updatedAt

  @@index([routeId, stopOrder])
  @@index([routeOrderId])
  @@index([status])
}

model EmailVerificationToken {
  id        String    @id @default(uuid())
  token     String    @unique
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([token])
  @@index([userId])
}

model Review {
  id         String   @id @default(uuid())
  rating     Int      // 1-5
  comment    String?  // Max 500 tecken, valfritt

  bookingId  String   @unique // En recension per bokning
  booking    Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  customerId String
  customer   User     @relation("CustomerReviews", fields: [customerId], references: [id])

  providerId String
  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)

  // Leverantörssvar
  reply      String?  // Max 500 tecken
  repliedAt  DateTime?

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([providerId, createdAt])
  @@index([customerId])
}
