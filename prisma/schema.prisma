// Equinet - Booking platform for horse service providers
// Database schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL")
}

model User {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String
  userType     String // 'provider' eller 'customer'
  firstName    String
  lastName     String
  phone        String?

  // Admin flag
  isAdmin      Boolean  @default(false)

  // Blocked by admin
  isBlocked    Boolean  @default(false)

  // Manual customer (created by provider, cannot log in)
  isManualCustomer Boolean @default(false)

  // Email verification
  emailVerified   Boolean   @default(false)
  emailVerifiedAt DateTime?

  // Email reminder preferences
  emailRemindersEnabled Boolean @default(true)

  // Geographic location (for customers to enable route matching)
  city         String?
  address      String?
  latitude     Float?
  longitude    Float?
  municipality String?  // Kommun (for route announcement matching)

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  provider                  Provider?
  bookings                  Booking[]
  notifications             Notification[]
  routeOrders               RouteOrder[]
  emailVerificationTokens   EmailVerificationToken[]
  reviews                   Review[]   @relation("CustomerReviews")
  customerReviewsReceived   CustomerReview[] @relation("CustomerReviewsReceived")
  horses                    Horse[]
  horseNotes                HorseNote[] @relation("HorseNoteAuthor")
  customerNotesReceived     ProviderCustomerNote[] @relation("CustomerNotesReceived")
  groupBookingRequests      GroupBookingRequest[]
  groupBookingParticipations GroupBookingParticipant[]
  uploads                   Upload[]
  bookingSeries             BookingSeries[]
  passwordResetTokens       PasswordResetToken[]
  follows                   Follow[]
  pushSubscriptions         PushSubscription[]
  notificationDeliveries    NotificationDelivery[]
  municipalityWatches       MunicipalityWatch[]

  @@index([latitude, longitude]) // For geo-queries
  @@index([municipality])
  providerCustomerLinks ProviderCustomer[]
}

model Provider {
  id              String   @id @default(uuid())
  userId          String   @unique
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  businessName    String
  description     String?
  address         String?
  city            String?
  postalCode      String?

  // NEW: Geographic coordinates (geocoded from address)
  latitude        Float?
  longitude       Float?
  serviceAreaKm   Float?   @default(50) // Max service radius in km

  serviceArea     String? // DEPRECATED: JSON array av områden (keep for backward compatibility)
  profileImageUrl String?
  isActive        Boolean  @default(true)
  acceptingNewCustomers Boolean @default(true)

  // AI vocabulary for voice work logging (JSON string)
  vocabularyTerms String?

  // Self-service reschedule settings
  rescheduleEnabled         Boolean @default(true)
  rescheduleWindowHours     Int     @default(24)    // Minsta timmar före bokning
  maxReschedules            Int     @default(2)     // Max per bokning
  rescheduleRequiresApproval Boolean @default(false) // true = status -> pending

  // Recurring booking settings
  recurringEnabled          Boolean @default(true)
  maxSeriesOccurrences      Int     @default(12)    // Max bokningar per serie

  // Verification
  isVerified      Boolean   @default(false)
  verifiedAt      DateTime?
  verifiedBy      String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  services               Service[]
  availability           Availability[]
  availabilityExceptions AvailabilityException[]
  bookings               Booking[]
  routes                 Route[]
  routeOrders            RouteOrder[] // NEW: Provider-announced route orders
  reviews                Review[]
  customerReviews        CustomerReview[] @relation("ProviderCustomerReviews")
  verifications          ProviderVerification[]
  groupBookingRequests   GroupBookingRequest[]
  fortnoxConnection      FortnoxConnection?
  manualBookings         Booking[] @relation("ManualBookings")
  horseServiceIntervals  HorseServiceInterval[]
  customerNotes          ProviderCustomerNote[] @relation("ProviderCustomerNotes")
  manualCustomers        ProviderCustomer[]
  bookingSeries          BookingSeries[]
  followers              Follow[]

  @@index([isActive, createdAt])
  @@index([city])
  @@index([businessName])
  @@index([latitude, longitude]) // NEW: For geo-queries
}

model Service {
  id              String   @id @default(uuid())
  providerId      String
  provider        Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  name            String
  description     String?
  price           Float
  durationMinutes Int
  isActive                  Boolean  @default(true)
  recommendedIntervalWeeks  Int?     // Recommended rebooking interval in weeks (null = no reminder)
  createdAt                 DateTime @default(now())

  bookings      Booking[]
  announcements RouteOrder[] // Many-to-many: announcements using this service
  bookingSeries BookingSeries[]
  customerServiceIntervals CustomerHorseServiceInterval[]
  horseServiceIntervals    HorseServiceInterval[]

  @@index([providerId, isActive])
}

model Availability {
  id         String   @id @default(uuid())
  providerId String
  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  dayOfWeek  Int // 0-6 (0=Måndag, 6=Söndag)
  startTime  String // Format: "09:00"
  endTime    String // Format: "17:00"
  isClosed   Boolean  @default(false) // true = Stängt hela dagen
  isActive   Boolean  @default(true) // false = Raderad/inaktiv
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([providerId, dayOfWeek])
}

// Datumbaserade undantag för tillgänglighet (har prioritet över veckoschema)
model AvailabilityException {
  id         String   @id @default(uuid())
  providerId String
  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  date       DateTime @db.Date // Specifikt datum (endast datum, ingen tid)
  isClosed   Boolean  @default(true) // true = stängt hela dagen
  startTime  String? // Alternativa öppettider (null = stängt)
  endTime    String?
  reason     String? // Valfri anledning ("Semester", "Sjuk", etc.)

  // Arbetsplats för dagen (US-2)
  location   String?  // "Sollebrunn", "Alingsås centrum"
  latitude   Float?
  longitude  Float?

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([providerId, date])
  @@index([providerId, date])
}

model Booking {
  id            String      @id @default(uuid())
  customerId    String
  customer      User        @relation(fields: [customerId], references: [id])
  providerId    String
  provider      Provider    @relation(fields: [providerId], references: [id])
  serviceId     String
  service       Service     @relation(fields: [serviceId], references: [id])
  routeOrderId  String?
  routeOrder    RouteOrder? @relation(fields: [routeOrderId], references: [id])
  bookingDate   DateTime
  startTime     String
  endTime       String
  timezone      String      @default("Europe/Stockholm") // Timezone för korrekt DST-hantering
  status        String      @default("pending") // pending, confirmed, cancelled, completed
  customerNotes        String?
  providerNotes        String?   // Provider's notes about the booking (visible in horse timeline)
  cancellationMessage  String?   // Message from whoever cancelled the booking
  horseName     String?
  horseInfo     String?
  horseId       String?
  horse         Horse?      @relation(fields: [horseId], references: [id])

  // Recurring booking series
  bookingSeriesId   String?
  bookingSeries     BookingSeries? @relation(fields: [bookingSeriesId], references: [id], onDelete: SetNull)

  // Reschedule tracking
  rescheduleCount   Int @default(0)

  // Beräknad restid till denna bokning (för historik/rapportering)
  travelTimeMinutes Int?

  // Manual booking fields (created by provider on behalf of customer)
  isManualBooking     Boolean  @default(false)
  createdByProviderId String?
  createdByProvider   Provider? @relation("ManualBookings", fields: [createdByProviderId], references: [id])

  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  payment       Payment?
  review        Review?
  customerReview CustomerReview?
  groupBookingParticipant GroupBookingParticipant?

  @@unique([providerId, bookingDate, startTime, endTime], name: "unique_booking_slot") // Förhindra exakta dubbletter vid race conditions
  @@index([providerId, bookingDate, status])
  @@index([customerId, bookingDate])
  @@index([customerId, status])
  @@index([serviceId])
  @@index([routeOrderId])
  @@index([horseId])
  @@index([createdByProviderId])
  @@index([bookingSeriesId])
}

model Horse {
  id           String   @id @default(uuid())
  ownerId      String
  owner        User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  name         String
  breed        String?  // Ras (t.ex. "Svenskt varmblod", "Islandshäst")
  birthYear    Int?     // Födelseår (inte ålder - statiskt värde)
  color        String?  // Färg (t.ex. "Fux", "Brun", "Skimmel")
  gender       String?  // "mare" | "gelding" | "stallion" (sto/valack/hingst)
  specialNeeds String?  // Medicinska behov, allergier, temperament etc.
  registrationNumber String?  // UELN (Unique Equine Life Number)
  microchipNumber    String?  // Mikrochip-ID (ISO 11784/11785)
  photoUrl     String?  // URL to horse photo (Supabase Storage)

  isActive     Boolean  @default(true) // Soft delete
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  bookings     Booking[]
  notes        HorseNote[]
  groupBookingParticipants GroupBookingParticipant[]
  profileTokens HorseProfileToken[]
  serviceIntervals HorseServiceInterval[]
  customerServiceIntervals CustomerHorseServiceInterval[]
  bookingSeries BookingSeries[]

  @@index([ownerId, isActive])
}

model HorseProfileToken {
  id        String   @id @default(cuid())
  horseId   String
  horse     Horse    @relation(fields: [horseId], references: [id], onDelete: Cascade)
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([token])
  @@index([horseId])
}

model Upload {
  id             String                @id @default(cuid())
  userId         String
  user           User                  @relation(fields: [userId], references: [id])
  bucket         String                // "avatars", "horses", "services", "verifications"
  path           String                // Supabase Storage path
  url            String                // Public URL
  mimeType       String
  originalName   String?               // Original filename from upload
  sizeBytes      Int
  verificationId String?
  verification   ProviderVerification? @relation(fields: [verificationId], references: [id], onDelete: SetNull)
  createdAt      DateTime              @default(now())

  @@index([userId])
  @@index([bucket, path])
  @@index([verificationId])
}

model FortnoxConnection {
  id            String   @id @default(cuid())
  providerId    String   @unique
  provider      Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  accessToken   String   // Encrypted
  refreshToken  String   // Encrypted
  expiresAt     DateTime
  companyId     String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([providerId])
}

model Payment {
  id                String    @id @default(uuid())
  bookingId         String    @unique
  booking           Booking   @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  amount            Float     // Belopp i SEK
  currency          String    @default("SEK")

  // Payment provider (mock för demo, stripe/swish för produktion)
  provider          String    @default("mock") // "mock" | "stripe" | "swish"
  providerPaymentId String?   // Externt betalnings-ID

  // Status tracking
  status            String    @default("pending") // pending, succeeded, failed, refunded
  paidAt            DateTime?

  // Kvitto/Faktura
  invoiceNumber     String?   @unique
  invoiceUrl        String?   // URL till PDF-kvitto

  // Fortnox integration
  fortnoxInvoiceId  String?
  fortnoxStatus     String?   // "draft" | "sent" | "paid"
  sentToFortnoxAt   DateTime?

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([bookingId, status])
  @@index([status, paidAt])
}

model Notification {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  type      String
  message   String
  isRead    Boolean  @default(false)
  linkUrl   String?  // Navigation target, e.g. "/customer/bookings"
  metadata  String?  // JSON string with extra context (bookingId, providerId, etc.)
  createdAt DateTime @default(now())

  @@index([userId, isRead])    // "Olästa notifikationer för användare"
  @@index([userId, createdAt]) // "Senaste notifikationer"
}

// Route-based delivery models
model RouteOrder {
  id                  String   @id @default(uuid())

  // Customer-initiated fields (nullable when provider-announced)
  customerId          String?
  customer            User?    @relation(fields: [customerId], references: [id])

  // NEW: Provider-announced fields
  providerId          String?
  provider            Provider? @relation(fields: [providerId], references: [id])
  announcementType    String   @default("customer_initiated") // 'customer_initiated' | 'provider_announced'

  // Shared fields (used by both flows)
  serviceType         String // t.ex. 'hovslagning', 'massage'
  address             String
  latitude            Float?   // Optional - geocoding not required for MVP
  longitude           Float?   // Optional - geocoding not required for MVP
  municipality        String?  // Kommun (nullable for legacy announcements)
  numberOfHorses      Int      @default(1)
  dateFrom            DateTime
  dateTo              DateTime
  priority            String   @default("normal") // 'normal' eller 'urgent'
  specialInstructions String?
  contactPhone        String?  // Optional - not needed for provider announcements
  status              String   @default("pending") // 'pending', 'in_route', 'completed', 'cancelled'
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  routeStops RouteStop[]
  bookings   Booking[]
  services   Service[]  // Many-to-many: provider's services for this announcement
  deliveries NotificationDelivery[]

  @@index([status, serviceType])
  @@index([status, priority])
  @@index([customerId, status])
  @@index([dateFrom, dateTo, status])
  @@index([providerId, announcementType, status]) // NEW: Provider announcements
  @@index([latitude, longitude, announcementType]) // NEW: Geo-search
  @@index([municipality, announcementType, status]) // Municipality-based search
}

model Route {
  id                   String   @id @default(uuid())
  providerId           String
  provider             Provider @relation(fields: [providerId], references: [id])
  routeName            String
  routeDate            DateTime
  startTime            String // Format: "08:00"
  status               String   @default("planned") // 'planned', 'active', 'completed', 'cancelled'
  totalDistanceKm      Float?
  totalDurationMinutes Int?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  stops RouteStop[]

  @@index([providerId, routeDate, status])
  @@index([status])
}

model RouteStop {
  id                   String     @id @default(uuid())
  routeId              String?    // Optional - announcements don't have Route
  route                Route?     @relation(fields: [routeId], references: [id], onDelete: Cascade)
  routeOrderId         String
  routeOrder           RouteOrder @relation(fields: [routeOrderId], references: [id])
  stopOrder            Int // 1, 2, 3... ordning i rutten
  locationName         String?    // NEW: "Alingsås centrum", "Sollebrunn" (för provider announcements)
  address              String     // NEW: Full address for the stop
  latitude             Float?     // NEW: Optional - geocoding not required for MVP
  longitude            Float?     // NEW: Optional - geocoding not required for MVP
  estimatedArrival     DateTime?
  estimatedDurationMin Int        @default(60) // Beräknad tid på plats
  actualArrival        DateTime?
  actualDeparture      DateTime?
  status               String     @default("pending") // 'pending', 'in_progress', 'completed', 'problem'
  problemNote          String?
  createdAt            DateTime   @default(now())
  updatedAt            DateTime   @updatedAt

  @@index([routeId, stopOrder])
  @@index([routeOrderId])
  @@index([status])
}

model EmailVerificationToken {
  id        String    @id @default(uuid())
  token     String    @unique
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([token])
  @@index([userId])
}

model PasswordResetToken {
  id        String    @id @default(uuid())
  token     String    @unique
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([token])
  @@index([userId])
}

model Review {
  id         String   @id @default(uuid())
  rating     Int      // 1-5
  comment    String?  // Max 500 tecken, valfritt

  bookingId  String   @unique // En recension per bokning
  booking    Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  customerId String
  customer   User     @relation("CustomerReviews", fields: [customerId], references: [id])

  providerId String
  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)

  // Leverantörssvar
  reply      String?  // Max 500 tecken
  repliedAt  DateTime?

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([providerId, createdAt])
  @@index([customerId])
}

// Customer reviews (provider → customer, immutable)
model CustomerReview {
  id         String   @id @default(uuid())
  rating     Int      // 1-5
  comment    String?  // Max 500 tecken, valfritt

  bookingId  String   @unique // En recension per bokning
  booking    Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  providerId String
  provider   Provider @relation("ProviderCustomerReviews", fields: [providerId], references: [id], onDelete: Cascade)

  customerId String
  customer   User     @relation("CustomerReviewsReceived", fields: [customerId], references: [id])

  createdAt  DateTime @default(now())

  @@index([providerId, createdAt])
  @@index([customerId])
}

model HorseNote {
  id        String   @id @default(uuid())
  horseId   String
  horse     Horse    @relation(fields: [horseId], references: [id], onDelete: Cascade)
  authorId  String
  author    User     @relation("HorseNoteAuthor", fields: [authorId], references: [id])
  category  String   // "veterinary" | "farrier" | "general" | "injury" | "medication"
  title     String   // "Vaccination - influensa"
  content   String?  // Longer description
  noteDate  DateTime // When the event occurred (not created)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([horseId, noteDate])
  @@index([authorId])
}

model ProviderVerification {
  id          String    @id @default(uuid())
  providerId  String
  provider    Provider  @relation(fields: [providerId], references: [id], onDelete: Cascade)
  type        String    // "education" | "organization" | "certificate" | "experience" | "license"
  title       String    // "Wångens gesällprov"
  description String?
  issuer      String?   // Utfärdare (skola, organisation)
  year        Int?      // År kompetensen erhölls
  status      String    @default("pending") // "pending" | "approved" | "rejected"
  reviewedAt  DateTime?
  reviewedBy  String?
  reviewNote  String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  images      Upload[]

  @@index([providerId, status])
  @@index([status, createdAt])
}

// Group Booking - coordination of multiple customers at same location
model GroupBookingRequest {
  id               String   @id @default(uuid())
  creatorId        String
  creator          User     @relation(fields: [creatorId], references: [id])
  serviceType      String   // t.ex. "hovslagning", "massage"
  providerId       String?  // Optional - can be matched later
  provider         Provider? @relation(fields: [providerId], references: [id])
  locationName     String   // "Sollebrunn Ridklubb"
  address          String
  latitude         Float?
  longitude        Float?
  dateFrom         DateTime
  dateTo           DateTime
  notes            String?
  maxParticipants  Int      @default(10)
  status           String   @default("open") // "open" | "matched" | "completed" | "cancelled"
  inviteCode       String   @unique // 8-character unique code
  joinDeadline     DateTime?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  participants     GroupBookingParticipant[]

  @@index([creatorId, status])
  @@index([status, dateFrom])
  @@index([inviteCode])
  @@index([providerId, status])
  @@index([latitude, longitude])
}

model GroupBookingParticipant {
  id                    String   @id @default(uuid())
  groupBookingRequestId String
  groupBookingRequest   GroupBookingRequest @relation(fields: [groupBookingRequestId], references: [id], onDelete: Cascade)
  userId                String
  user                  User     @relation(fields: [userId], references: [id])
  numberOfHorses        Int      @default(1)
  horseId               String?
  horse                 Horse?   @relation(fields: [horseId], references: [id])
  horseName             String?
  horseInfo             String?
  notes                 String?
  status                String   @default("joined") // "joined" | "booked" | "cancelled"
  bookingId             String?  @unique // Linked when provider matches
  booking               Booking? @relation(fields: [bookingId], references: [id])
  joinedAt              DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([groupBookingRequestId, userId])
  @@index([groupBookingRequestId, status])
  @@index([userId])
  @@index([horseId])
}

// Per-horse, per-service revisit interval override (provider-specific)
// Allows providers to set custom rebooking intervals per horse per service
model HorseServiceInterval {
  id                    String   @id @default(uuid())
  horseId               String
  horse                 Horse    @relation(fields: [horseId], references: [id], onDelete: Cascade)
  providerId            String
  provider              Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  serviceId             String
  service               Service  @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  revisitIntervalWeeks  Int      // 1-52
  notes                 String?  // "Hovproblem, behover tatare besok"
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([horseId, providerId, serviceId])
  @@index([providerId])
  @@index([horseId])
  @@index([serviceId])
}

// Per-horse service interval set by customer (customer-controlled priority)
// Priority: CustomerHorseServiceInterval > HorseServiceInterval > Service.recommendedIntervalWeeks
model CustomerHorseServiceInterval {
  id            String   @id @default(uuid())
  horseId       String
  horse         Horse    @relation(fields: [horseId], references: [id], onDelete: Cascade)
  serviceId     String
  service       Service  @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  intervalWeeks Int      // 1-104
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([horseId, serviceId])
  @@index([horseId])
  @@index([serviceId])
}

// Provider's private notes about a customer (journal/log)
model ProviderCustomerNote {
  id         String   @id @default(uuid())
  providerId String
  provider   Provider @relation("ProviderCustomerNotes", fields: [providerId], references: [id], onDelete: Cascade)
  customerId String
  customer   User     @relation("CustomerNotesReceived", fields: [customerId], references: [id])
  content    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([providerId, customerId, createdAt])
  @@index([customerId])
}

// Junction table: manually added customers (provider -> customer without booking)
model ProviderCustomer {
  id         String   @id @default(uuid())
  providerId String
  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  customerId String
  customer   User     @relation(fields: [customerId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@unique([providerId, customerId])
  @@index([providerId, createdAt])
  @@index([customerId])
}

// Recurring booking series
model BookingSeries {
  id               String    @id @default(uuid())
  customerId       String
  customer         User      @relation(fields: [customerId], references: [id])
  providerId       String
  provider         Provider  @relation(fields: [providerId], references: [id])
  serviceId        String
  service          Service   @relation(fields: [serviceId], references: [id])
  horseId          String?
  horse            Horse?    @relation(fields: [horseId], references: [id])
  intervalWeeks    Int
  totalOccurrences Int
  createdCount     Int
  startTime        String    // "HH:MM"
  status           String    @default("active") // active | cancelled | completed
  cancelledAt      DateTime?
  createdAt        DateTime  @default(now())

  bookings         Booking[]

  @@index([customerId])
  @@index([providerId])
  @@index([status])
}

// Follow: customer follows provider for route announcements
model Follow {
  id         String   @id @default(uuid())
  customerId String
  customer   User     @relation(fields: [customerId], references: [id], onDelete: Cascade)
  providerId String
  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@unique([customerId, providerId])
  @@index([customerId])
  @@index([providerId])
}

// Dedup: track which route announcement notifications have been sent
model NotificationDelivery {
  id           String     @id @default(uuid())
  routeOrderId String
  routeOrder   RouteOrder @relation(fields: [routeOrderId], references: [id], onDelete: Cascade)
  customerId   String
  customer     User       @relation(fields: [customerId], references: [id], onDelete: Cascade)
  channel      String     // "in_app" | "email" | "push"
  createdAt    DateTime   @default(now())

  @@unique([routeOrderId, customerId, channel])
  @@index([routeOrderId])
}

// Push subscription stub (for future web push notifications)
model PushSubscription {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  endpoint  String   @unique
  p256dh    String
  auth      String
  createdAt DateTime @default(now())

  @@index([userId])
}

// Feature flags stored in database (replaces Redis)
model FeatureFlag {
  id        String   @id @default(cuid())
  key       String   @unique
  enabled   Boolean  @default(false)
  updatedAt DateTime @updatedAt
  updatedBy String?
  createdAt DateTime @default(now())
}

// Municipality watch: customer watches a municipality + service type for notifications
model MunicipalityWatch {
  id              String   @id @default(uuid())
  customerId      String
  customer        User     @relation(fields: [customerId], references: [id], onDelete: Cascade)
  municipality    String
  serviceTypeName String   // Free text service type, e.g. "Hovslagning"
  createdAt       DateTime @default(now())

  @@unique([customerId, municipality, serviceTypeName])
  @@index([municipality, serviceTypeName])
  @@index([customerId])
}
